---
layout:     post
title:      "JVM - 方法区的演进"
subtitle:   " \"JVM Daily Notes - 15\""
date:       2021.01.14 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - JVM
---

> *"Keep Learning JVM"*

# 方法区

## 方法区的演进

1. HotSpot中方法区的变化：
   - JDK 1.6 之前：
     - 有永久代，静态变量存放在永久代上；
   - JDK１.7:
     - 有永久代，但已经逐渐去除，字符串常量池、静态变量移除，保存在堆中；
   - JDK 1.8 及之后：
     - 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆里；
2. 为什么要放到元空间呢？
   - 因为`JRockit`和`HotSpot`的合并，前者本就没有永久代的概念；
   - 为永久代设置空间大小是很难确定的；
   - 对永久代进行调优是很困难的（`Full GC`）。
3. 为什么移动字符串常量池`StringTable`?
   - 因为永久代的回收效率比较低，在`Full GC`的时候才会触发，但前者是因为老年代空间不足、永久代不足的时候才会触发。这就导致`StringTable`的回收效率不高。而我们开发过程中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，可以及时回收内存。
4. 静态变量放在那里？
   - 静态引用对应的对象实体始终都存放在堆空间，但引用名的位置发生了变化；
   - JDK 9 引入了`JHSDB`工具，可以用来分析；

## 方法区的垃圾收集

首先方法区是一个概念，永久代或元空间是其实现。

方法区的垃圾收集主要回收两部分内容：

- 常量池中废弃的常量；
- 不再使用的类型。

但这个区域的回收效果难以令人满意，尤其是类型的卸载，条件非常苛刻。但又是非常有必要的。

方法区的常量池中主要存放的两大类常量包括：字面量和符号引用，字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为`final`的常量池等。而符号引用则属于编译原理方面的概念，包括下面三类常量：

- 类和接口的全限定名；
- 字段的名称和描述符；
- 方法的名称和描述符。

HotSpot对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收；

回收废弃常量与回收Java堆中的对象非常类似。

判断一个类型是否属于“不再被使用的类”的条件比较苛刻，需要同时满足下面三点：

- 该类（包括其派生子类）的所有实例都已经被回收；
- 加载该类的类加载器已经被回收，除非是经过精心设计的可替换类加载器的场景才能实现；
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

在大量使用反射、动态代理、`CGLib`等字节码框架等等场景下，类型卸载还是有必要的。



































