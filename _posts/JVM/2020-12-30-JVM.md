---
layout:     post
title:      "JVM - Daily Notes - 05"
subtitle:   " \"JAVA Knowledge - JVM\""
date:       2020.12.30 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - JVM

---

> *"Keep Learning JVM"*

# 双亲委派机制

## 其他相关内容

1. 在JVM中两个`class`对象是否相同需要满足两个条件：

    - 类的完整类名相同，包括包名；
    - 加载这个类的`ClassLoader`(指`ClassLoader`实例对象)必须完全相同；

2. 对类加载器的引用

    JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是否是相同的。

3. 类的主动使用和被动使用

    其中，主动使用包括：

        - 创建类的实例；
        - 访问某个类或者接口的静态变量，或者对该静态变量赋值；
        - 调用类的静态方法；
        - 反射（比如：`Class.forName("org.lov3camille.trend")`）；
        - 初始化一个类的子类；
        - Java虚拟机启动时被标名为启动类的类；
        - JDK 7 开始提供的动态语言支持。

除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化。

# 运行时数据区概述以及线程

不同的JVM对于内存的划分方式和管理机制存在着部分差异。下面来看下JVM的内存布局:

- 程序计数器；
- 本地方法栈；
- 虚拟机栈（包括多个栈帧，栈帧又包括（局部变量表；操作栈；动态链接；方法返回地址）；
- 堆（新生代和永久代）；
- 元数据区（JDK 1.8 之后，之前叫做永久代）

Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中一些会随着虚拟机的创建而创建，随着虚拟机的关闭而销毁，另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建而销毁。

具体地讲，每个线程有自己独有的程序计数器、本地方法栈和虚拟机栈；同时它们也会共享堆、堆外内存（永久代或者元空间、代码缓存）。注意，每个Java程序运行时都相当于启动了一个JVM进程，每个JVM进程都对应一个`Runtime`实例,可以通过`getRuntime()`方法来获取当前运行的`Runtime`对象的引用,用以检测当前虚拟机的状态以及控制虚拟机的行为.

## 线程

- 线程是一个程序里的运行单元,JVM允许一个Java程序运行时有多个线程并发执行;
- 在HotSpot JVM里, 每个线程都与操作系统的本地线程直接映射.当一个Java线程准备好执行后,此时一个操作系统的本地线程也同时创建.Java线程终止后,本地线程也会得到回收;
- 操作系统负责所有线程的安排调度到任何一个可用的CPU上,一旦本地线程初始化成功,他就会调用Java线程中的`run()`方法.

### JVM系统线程

如果你使用`jconsole`或者是任何一个调试工具,都能看到在后台有许多线程的运行.这些后台线程不包括调用`main`方法的线程以及所有这个方法自己创建的线程.
这些线程主要包括(可以分为守护线程和普通线程):

- 虚拟机线程;
- 周期任务线程;
- GC线程；
- 编译线程；
- 信号调度线程.　

# 程序计数器(Program Counter Register)

- JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟,作用是存储指向下一条指令的地址,也即将要执行的指令代码,由执行引擎来读取下一条指令;
- 它是一块很小的内存空间,运行速度很快;
- 在JVM规范中,程序计数器是线程私有的,生命周期和线程保持一致;
- 任何时间一个线程都只有一个方法在执行,也就是所谓的当前方法.程序计数器会存储当前线程正在执行的Java程序的JVM指令内存地址;或者,如果是在执行native方法,则处于未指定值(undefined)的状态.
- 它是程序控制流的指示器,分支/循环/跳转/异常处理/线程恢复等基础功能都需要依赖这个计数器来完成;
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令;
- 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

## 两个常见问题:

1. 使用PC寄存器存储字节码指令有什么用,为什么使用PC寄存器来记录当前线程的执行地址?

   因为CPU需要不停地切换多个线程,这时候需要保证切换回来之后,知道从哪里继续执行;JVM的字节码解释器就需要改变PC寄存器的值来明确下一条应该执行什么样的字节码指令．

2. PC寄存器为什么会被设定为线程私有的?

   为了准确地记录各个线程当前正在执行的字节码的指令地址,最好的办法是为每个线程都分配一个PC寄存器.

## CPU时间片

CPU时间片即CPU分配给各个程序的时间,每个线程被分配一个时间段,叫做它的时间片.

在宏观上, 我们可以同时打开多个应用程序,各个程序并行不悖;
但在微观上,因为只有一个CPU,所以一次只能处理程序要求的一部分,如何处理公平,一种方法就是引入时间片,每个程序轮流执行.