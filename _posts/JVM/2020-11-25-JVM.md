---
layout:     post
title:      "JVM - Daily Notes - 01"
subtitle:   " \"JAVA Knowledge - JVM\""
date:       2020.11.25 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - JVM


---

> *"Keep Learning JVM"*

# Java 内存区域与内存溢出异常

## 基本概念

运行时数据区域包括：
   - 程序计数器：较小的内存空间，可以看成当前线程所执行的字节码的行号指示器；为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。
   - Java虚拟机栈：同样是线程私有，生命周期与线程相同；描述的是Java方法执行的线程内存模型，包括局部变量表、操作数栈、方法出口等信息，每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。要注意的是，局部变量存放的对象引用并不等同于对象本身，并且内存空间在编译期间就已经完成分配了。
   - 本地方法栈：区别只是它是为虚拟机使用到的本地（Native）方法服务。
   - Java堆：这是虚拟机管理内存中最大的一块，所有线程共享并在虚拟机启动时创建；唯一目的就是存放对象实例；它也是垃圾收集器管理的内存区域，也叫“GC堆”；从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率；Java堆可以是物理上不连续的，但必须是逻辑上连续的。
   - 方法区：与Java堆类似，它存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展之外，甚至可以选择不实现垃圾收集。
   - 运行时常量池：它是方法区的一部分，`Class`文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用。另外，运行期间也可以将新的常量放入池中，一个经典的例子就是`String`类的`intern()`方法。
   - 直接内存：直接内存并不是虚拟机运行时数据区的一部分。它可以通过`Native`函数库直接分配堆外内存，然后通过一个存储在Java堆里面的`DirectByteBuffer`对象作为这块内存的引用进行操作。

## HotSpot虚拟机对象概念

### 对象的创建

Step 1. 当Java虚拟机遇到一条字节码`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那必须先执行相应的类加载过程。

Step 2. 类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后便可以完全确定。这时有两种情况，如果Java堆中的内存是规整的，那么只需要进行“指针碰撞”。但如果不是规整的，已使用的内存和闲置的内存互相交织在一起，虚拟机就必须维护一个列表，记录哪些内存块是可用的，这种分配方式叫做“空闲列表”。Java堆是否规整由采用的垃圾收集器是否有空间压缩整理的能力决定。

Step 3. 上面所说的分配方式在并发情况下也并不是线程安全的。有两种解决方案，一种是对分配内存空间的动作进行同步处理；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，哪个线程要分配内存，就在哪个线程的本地缓存区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

Step 4. 内存分配完成后，虚拟机必须将分配到的内存空间都初始化为零值，这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。

Step 5. 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例，元数据信息，对象的哈希码，对象的GC分代年龄等信息，这些信息存放在对象的对象头（Object Overhead）中。

Step 6. 虚拟机这块，一个新的对象已经产生了，但是Java程序这块才刚刚开始，`new`指令后会接着执行`<init>()`方法（构造函数），按照程序员的意愿对其初始化，而不是使用字段的初始零值。至此，真正可用的对象才完全被构造出来。