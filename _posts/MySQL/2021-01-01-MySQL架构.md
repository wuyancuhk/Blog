---
layout:     post
title:      "MySQL - 架构介绍"
subtitle:   " \"MySQL Knowledge - 高级部分\""
date:       2021.01.01 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - MySQL

---

> *"Keep Learning MySQL"*

# 数据库的事务

1. 一个事务是一个完整的业务逻辑单元，不可再分。里面的执行语句必须同时成功或者同时失败。这里就需要用到事务机制。

2. 和事务相关的语句只有`DML`语句（`delete`, `update`, `insert`）。

3. 开启事务机制后，执行会记录到数据库的操作历史中，并不会向文件中保存数据，也就是说不会改变硬盘上的数据，提交（`commit`）或者回滚(`rollback`)事务都会结束该事务。另外，`savepoint`代表保存点，可以回滚到该处。

4. 事务的四大特性：
    - 原子性：事务是最小的工作单元，不可再分；
    - 隔离性：事务A和事务B之间具有隔离性；
    - 一致性：事务必须保证多条`DML`语句同时成功或者同时失败；
    - 持久性：最终的数据必须持久化到硬盘文件中，事务才算真正结束。
    
5. 关于事务的隔离性：
    - 事务之间存在隔离级别：
        - 第一级别：读取未提交（read uncommitted)，对方事务还没提交，我们当前事务可以读取到对方未提交的数据，存在脏读现象，表示读到了缓存中的未处理的数据；
        - 第二级别：读且提交（read committed），读已提交存在的问题是：不可重复读，但是解决了脏读现象；
        - 第三级别：可重复读（repeatable read），解决了不可重复读的问题，但出现了幻读问题；
        - 第四级别：序列化/串行化读，解决了所有问题，但是效率低，需要事务排队。
    - Oracle数据库默认的隔离级别是：读已提交，MySQL的隔离级别是可重复读。
    - MySQL事务默认情况下是自动提交的，可以使用`start transaction`取消自动提交.
    
6. 几种常用指令：

    ```mysql
    set global transaction isolation level read_uncommitted; //设置全局隔离级别；
    select @@global.tx_isolation,@@tx_isolation; //查看全局的和当前会话的隔离界别。
    ```

    

# MySQL的逻辑架构

1. 下图是MySQL的简单逻辑架构图：

![image-20210101145548300](https://i.loli.net/2021/01/01/j9aDOq3SlKyeHdI.png)

2. Mysql是`C/S`架构的数据库。

3. MySQL架构总共三层，在上图中以虚线作为划分。

4. 首先，最上层的客户端指的是MySQL的图形化连接软件和各种编程语言的MySQL连接模块，例如Python的`MySQLdb`模块，还有`API`接口等等。

5. 第二层就是`MySQL`的核心服务，也称为`service`层。包括：查询解析、分析、优化、缓存以及所有的内置函数（例如：日期、时间、数学和加密函数）。同时，所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

6. 第三层就是存储层，也就是`innoDB`存储引擎。存储引擎负责MySQL中数据的存储和提取。

# MySQL系统架构图

上图只是MySQL系统架构大的模块图，其实每一层的结构都相当复杂，下图就是详细模块图：

![image-20210101150031374](https://i.loli.net/2021/01/01/Bsz61xM84NEPSFZ.png)

1、Connectors

指的是不同语言与SQL的交互。

2、Connection Management

管理用户连接，线程处理等需要缓存的需求。负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。

３、 Management Serveices & Utilities 系统管理和控制工具。

4、 SQL Interface

接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface

5、 Parser

SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 query 进行分类然后转发给各个对应的处理模块。

主要功能：  

a 、 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的；

b、 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的。

6、 Optimizer

查询优化器：SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求query，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果。使用的是“选取-投影-联接”策略进行查询：

用一个例子就可以理解： `select uid,name from user where gender = 1; `这个`select `查询先根据`where` 语句进行选取，而不是先将表全部查询出来以后再进行`gender`过滤；然后根据`uid`和`name`进行属性投影，而不是将属性全部取出以后再进行过滤。最后将这两个查询条件联接起来生成最终查询结果。

7 、Cache和Buffer

查询缓存：主要功能是将客户端提交 给MySQL 的 `Select` 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个` hash `值 做一个对应。该 query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。

如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。

8 、存储引擎接口

MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。

注意：存储引擎是基于表的，而不是数据库。

# 存储引擎

## MyISAM和InnoDB区别

| 对比项   | MyISAM                                                 | InnoDB                                                       |
| -------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 主外键   | 不支持                                                 | 支持                                                         |
| 事务     | 不支持                                                 | 支持                                                         |
| 行表锁   | 表锁，即使操作一条记录也会所著整个表，不适合高并发操作 | 行锁，操作时只锁某一行，不对其他行有影响，适合进行高并发操作 |
| 缓存     | 只缓存索引，不缓存真实数据                             | 不仅缓存索引还要缓存真实数据，对内存的要求较高，而且内存大小对性能有决定性影响 |
| 表空间   | 小                                                     | 大                                                           |
| 关注点   | 性能                                                   | 事务                                                         |
| 默认安装 | Y                                                      | Y                                                            |

具体区别：

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  

3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 

4. InnoDB 不保存表的具体行数，执行` select count(*) from table` 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    

5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；