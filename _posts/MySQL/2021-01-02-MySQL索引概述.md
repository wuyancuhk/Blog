---
layout:     post
title:      "MySQL - 索引概述"
subtitle:   " \"MySQL Knowledge - 高级部分\""
date:       2021.01.02 12:29:00
author:     "Wuy"
header-img: "img/post-bg-2020.jpg"
catalog: true
tags:
    - 学习笔记
    - 读书
    - MySQL


---

> *"Keep Learning MySQL"*

# 索引概述

1. 索引是帮助MySQL高效获取数据的数据结构, 可以得到索引的本质:索引是一种数据结构. 索引的目的在于提高查询效率,类似于字典.
2. 数据本身之外,数据库还维护着一个满足特定查找算法的数据结构,这些数据以某种方式指向数据,这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引.
3. 索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存储在磁盘上;
4. 优势:
   - 提高了检索效率,减少了数据的IO;
   - 降低数据排序的成本你,降低了CPU的消耗
     劣势:

- 实际上索引也是一张表,该表保存了主键与索引字段,并指向实体表的记录,所以索引列也是要占空间的;
- 虽然索引大大加快了查询的速度,但也会降低更新表的速度.因为更新表的时候,MySQL不仅要保存数据,还要保存一下索引文件每次更新添加了索引列的字段,都会调整因为更新所带来的键值变化后的索引信息;
- 如果数据量较大,那么需要研究如何创建优秀的索引,或优化查询方法

## 索引分类

1. 单值索引

   即一个索引只包含单个列,一个表可以有多个单列索引.

2. 唯一索引

   索引列的值必须唯一,但允许空值

3. 复合索引

   即一个索引包含多个列.

4. 基本语法

- 创建: `create (unique) index indexName on mytable(columnname(length));`或者`alter table add (unique) indexName on (columnname(length))`
- 删除: `drop index (indexName) on mytable`
- 查看: `show index from table_name`

5. 索引结构：BTree 索引

## 创建索引的情况

1. 主键自动建立唯一索引；
2. 频繁作为查询条件的字段应该创建索引；
3. 查询中与其他表关联的字段，外键关系建立索引；
4. 频繁更新的字段不适合创建索引；
5. `where`条件里用不到的字段不创建索引；
6. 在高并发条件下倾向创建组合索引；
7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。
8. 查询中统计或分组字段。

## 不创建索引的情况

1. 表记录数据过少；
2. 经常增删改的表；
3. 如果某个数据列包含许多重复的内容，为它建立索引就没有太大意义。

## 索引性能分析

1. MySQL的常见瓶颈：

   - CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候；
   - IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候；
   - 服务器硬件的性能瓶颈：`top`,`free`,`iostat`或`vmstat`来查看系统的性能状态。

2. `Explain`的用法

   - 使用`Explain`关键字可以模拟优化器执行SQL查询语句，从而指导MySQL是如何处理你的SQL语句的。分析你的查询语句或者是表结构的性能瓶颈。

   - 作用主要包括：

     - 表的读取顺序；
     - 数据读取操作的数据类型；
     - 哪些索引可以使用；
     - 哪些索引实际被使用；
     - 表之间的引用；
     - 每张表有多少行被优化器查询

   - 执行计划包含的信息：

     ![image-20210103164250627](https://i.loli.net/2021/01/03/tBhiUmfFnIezHVy.png)

     - `id`: `id`相同的情况下, 执行顺序由上往下; 如果是子查询, `id`会递增, 且`id`越大的优先级越高;`table`字段里的`derived%d`里面的`%d`代表衍生执行`id`;
     - `select_type`：
       - `simple`：简单的`select`查询，不包括子查询或者`union`;
       - `primary`：查询中若包含任何复杂的子部分，最外层查询则被标记为`primary`:
       - `subquery`：在`select`或`where`列表中包含的子查询；
       - `derived`：在`from`列表中包含的子查询被标记为`derived`, MySQL会递归执行这些子查询，把结果放在临时表里；
       - `union`：若第二个`select`出现在`union`之后，则被标记为`union`; 若`union`包含在`from`子句的子查询中，外层`select`将被标记为：`derived`；
       - `union result`：代表获取两种`union`查询的结果的`select`语句。
     - `table`：代表这个查询是属于哪张表的；
     - `type`（访问类型排列）：
       - 结果值从最好到最坏依此是：`system`, `const`, `eq_ref`,`ref`,`fulltext`,`ref_or_null`,`index_merge`,`unique_subquery`,`index_subquery`,``range`,`index`,`ALL`；
       - 一般来说，得保证查询至少达到`range`级别，最好是`ref`；
       - `system`：表只有一行记录，这是`const`类型得特例，平时不会出现；
       - `const`：表示通过索引一次就找到了，用于比较`primary key`或者`unique`索引。由于只匹配一行数据，所以很快；
       - `eq_ref`：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描；
       - `ref`：非唯一性索引扫描，返回匹配某个单独值的所有行；
       - `range`：只检索给定范围的行，使用一个索引来选择行。`key`列显示使用了哪个索引，一般就是在`where`语句中出现了`between`，`<,>`，`in`等的查询。这种范围的扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引；
       - `index`：该类型只遍历索引树。这通常比`all`快，因为索引文件通常比数据文件小;
       - `all`：`Full Table Scan`，也就是全表扫描。
     - `possible_keys`和`keys`：
       - 前者代表可能应用在这张表的索引，一个或多个；查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用；
       - 后者代表实际使用的索引，如果为`Null`，则没有使用索引，若使用了覆盖索引，则只存在于`keys`字段中；
     - `key_len`：
       - 表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。
       - 显示的值为索引字段的最大可能长度，并非实际使用长度，即`key_len`是根据表定义计算而得，而不是通过表内检索得出的。
       - 注意，使用变长字段需要额外增加2个字节，使用`NULL`需要额外增加1个字节，因此对于是索引的字段，最好使用定长和`NOT NULL`定义，提高性能。
     - `ref`：
       - 显示索引的哪一列被使用了，如果可能的话，是一个常数。说明哪些列或常量被用于查找索引列上的值。
     - `rows`：
       - 根据表统计信息及索引选取情况，大致估算出找到所需的记录所需要读取的行数。
     - `Extra`：
       - 包含不适合在其他列显示但十分重要的信息:
       - `Using filesort`：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取；
       - `Using temporary`：使用了临时表保存中间结果，MySQL在对查询结果排序的时候使用临时表。常见于排序`order by`和分组查询`group by`;
       - `Using index`：表示相应的`select`操作中使用了覆盖索引，避免访问了表的数据行，效率可观；如果同时出现`using where`，表明索引被用来执行索引键值的查找；如果没有出现，则表明索引用来读取数据而非执行查00找动作；
       - `using where`：表面使用了`where`语句；
       - `using join buffer`：表明使用了连接缓存；
       - `impossible where`：`where`子句的值总是`false`:
       - `select tables optimized away`：查询计划生成阶段即完成优化；
       - `distinct`：优化`distinct`操作，在找到第一匹配的元组后即停止找同样值的动作。







































